// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
// swift-module-flags: -target i386-apple-watchos3.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RxCocoa
import CoreGraphics
import Dispatch
import Foundation
@_exported import RxCocoa
@_exported import RxRelay
import RxSwift
import Swift
import _Concurrency
public protocol DelegateProxyType : AnyObject {
  associatedtype ParentObject : AnyObject
  associatedtype Delegate
  static func registerKnownImplementations()
  static var identifier: Swift.UnsafeRawPointer { get }
  static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
  func forwardToDelegate() -> Self.Delegate?
  func setForwardToDelegate(_ forwardToDelegate: Self.Delegate?, retainDelegate: Swift.Bool)
}
extension RxCocoa.DelegateProxyType {
  public static var identifier: Swift.UnsafeRawPointer {
    get
  }
}
extension RxCocoa.DelegateProxyType {
  public static func register<Parent>(make: @escaping (Parent) -> Self)
  public static func createProxy(for object: Swift.AnyObject) -> Self
  public static func proxy(for object: Self.ParentObject) -> Self
  public static func installForwardDelegate(_ forwardDelegate: Self.Delegate, retainDelegate: Swift.Bool, onProxyForObject object: Self.ParentObject) -> RxSwift.Disposable
}
public protocol HasDelegate : AnyObject {
  associatedtype Delegate
  var delegate: Self.Delegate? { get set }
}
extension RxCocoa.DelegateProxyType where Self.Delegate == Self.ParentObject.Delegate, Self.ParentObject : RxCocoa.HasDelegate {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
public protocol HasDataSource : AnyObject {
  associatedtype DataSource
  var dataSource: Self.DataSource? { get set }
}
extension RxCocoa.DelegateProxyType where Self.Delegate == Self.ParentObject.DataSource, Self.ParentObject : RxCocoa.HasDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
@available(iOS 10.0, tvOS 10.0, *)
public protocol HasPrefetchDataSource : AnyObject {
  associatedtype PrefetchDataSource
  var prefetchDataSource: Self.PrefetchDataSource? { get set }
}
@available(iOS 10.0, tvOS 10.0, *)
extension RxCocoa.DelegateProxyType where Self.Delegate == Self.ParentObject.PrefetchDataSource, Self.ParentObject : RxCocoa.HasPrefetchDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
extension RxRelay.BehaviorRelay {
  final public func asDriver() -> RxCocoa.Driver<Element>
}
public enum SharingScheduler {
  public static var make: () -> RxSwift.SchedulerType {
    get
  }
  public static func mock(scheduler: RxSwift.SchedulerType, action: () throws -> Swift.Void) rethrows
  public static func mock(makeScheduler: @escaping () -> RxSwift.SchedulerType, action: () throws -> Swift.Void) rethrows
}
public typealias Driver<Element> = RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Element>
public struct DriverSharingStrategy : RxCocoa.SharingStrategyProtocol {
  public static var scheduler: RxSwift.SchedulerType {
    get
  }
  public static func share<Element>(_ source: RxSwift.Observable<Element>) -> RxSwift.Observable<Element>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.DriverSharingStrategy {
  public func asDriver() -> RxCocoa.Driver<Self.Element>
}
extension RxSwift.ObservableConvertibleType {
  public func asSignal(onErrorJustReturn: Self.Element) -> RxCocoa.Signal<Self.Element>
  public func asSignal(onErrorSignalWith: RxCocoa.Signal<Self.Element>) -> RxCocoa.Signal<Self.Element>
  public func asSignal(onErrorRecover: @escaping (_ error: Swift.Error) -> RxCocoa.Signal<Self.Element>) -> RxCocoa.Signal<Self.Element>
}
public protocol ControlEventType : RxSwift.ObservableType {
  func asControlEvent() -> RxCocoa.ControlEvent<Self.Element>
}
public struct ControlEvent<PropertyType> : RxCocoa.ControlEventType {
  public typealias Element = PropertyType
  public init<Ev>(events: Ev) where PropertyType == Ev.Element, Ev : RxSwift.ObservableType
  public func subscribe<Observer>(_ observer: Observer) -> RxSwift.Disposable where PropertyType == Observer.Element, Observer : RxSwift.ObserverType
  public func asObservable() -> RxSwift.Observable<RxCocoa.ControlEvent<PropertyType>.Element>
  public func asControlEvent() -> RxCocoa.ControlEvent<RxCocoa.ControlEvent<PropertyType>.Element>
  public func asInfallible() -> RxSwift.Infallible<RxCocoa.ControlEvent<PropertyType>.Element>
}
extension RxCocoa.ControlEvent {
  public func asSignal() -> RxCocoa.Signal<RxCocoa.ControlEvent<PropertyType>.Element>
}
public protocol SectionedViewDataSourceType {
  func model(at indexPath: Foundation.IndexPath) throws -> Any
}
extension RxSwift.InfallibleType {
  public func bind<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> RxSwift.Disposable
  public func bind(to relays: RxRelay.BehaviorRelay<Self.Element>...) -> RxSwift.Disposable
  public func bind(to relays: RxRelay.BehaviorRelay<Self.Element?>...) -> RxSwift.Disposable
  public func bind(to relays: RxRelay.PublishRelay<Self.Element>...) -> RxSwift.Disposable
  public func bind(to relays: RxRelay.PublishRelay<Self.Element?>...) -> RxSwift.Disposable
  public func bind(to relays: RxRelay.ReplayRelay<Self.Element>...) -> RxSwift.Disposable
  public func bind(to relays: RxRelay.ReplayRelay<Self.Element?>...) -> RxSwift.Disposable
}
extension RxSwift.InfallibleType {
  public func asDriver() -> RxCocoa.Driver<Self.Element>
}
public enum RxCocoaInterceptionMechanism {
  case unknown
  case kvo
  public static func == (a: RxCocoa.RxCocoaInterceptionMechanism, b: RxCocoa.RxCocoaInterceptionMechanism) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum RxCocoaObjCRuntimeError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown(target: Swift.AnyObject)
  case objectMessagesAlreadyBeingIntercepted(target: Swift.AnyObject, interceptionMechanism: RxCocoa.RxCocoaInterceptionMechanism)
  case selectorNotImplemented(target: Swift.AnyObject)
  case cantInterceptCoreFoundationTollFreeBridgedObjects(target: Swift.AnyObject)
  case threadingCollisionWithOtherInterceptionMechanism(target: Swift.AnyObject)
  case savingOriginalForwardingMethodFailed(target: Swift.AnyObject)
  case replacingMethodWithForwardingImplementation(target: Swift.AnyObject)
  case observingPerformanceSensitiveMessages(target: Swift.AnyObject)
  case observingMessagesWithUnsupportedReturnType(target: Swift.AnyObject)
}
extension RxCocoa.RxCocoaObjCRuntimeError {
  public var debugDescription: Swift.String {
    get
  }
}
public enum RxCocoaURLError : Swift.Error {
  case unknown
  case nonHTTPResponse(response: Foundation.URLResponse)
  case httpRequestFailed(response: Foundation.HTTPURLResponse, data: Foundation.Data?)
  case deserializationError(error: Swift.Error)
}
extension RxCocoa.RxCocoaURLError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RxSwift.Reactive where Base : Foundation.URLSession {
  public func response(request: Foundation.URLRequest) -> RxSwift.Observable<(response: Foundation.HTTPURLResponse, data: Foundation.Data)>
  public func data(request: Foundation.URLRequest) -> RxSwift.Observable<Foundation.Data>
  public func json(request: Foundation.URLRequest, options: Foundation.JSONSerialization.ReadingOptions = []) -> RxSwift.Observable<Any>
  public func json(url: Foundation.URL) -> RxSwift.Observable<Any>
}
extension RxSwift.Reactive where Base == Foundation.URLSession {
  public static var shouldLogRequest: (Foundation.URLRequest) -> Swift.Bool
}
public protocol KVORepresentable {
  associatedtype KVOType
  init?(KVOValue: Self.KVOType)
}
extension RxCocoa.ControlEvent {
  public func asDriver() -> RxCocoa.Driver<RxCocoa.ControlEvent<PropertyType>.Element>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.DriverSharingStrategy {
  public func drive<Observer>(_ observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  public func drive<Observer>(_ observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  public func drive(_ relays: RxRelay.BehaviorRelay<Self.Element>...) -> RxSwift.Disposable
  public func drive(_ relays: RxRelay.BehaviorRelay<Self.Element?>...) -> RxSwift.Disposable
  public func drive(_ relays: RxRelay.ReplayRelay<Self.Element>...) -> RxSwift.Disposable
  public func drive(_ relays: RxRelay.ReplayRelay<Self.Element?>...) -> RxSwift.Disposable
  public func drive<Result>(_ transformation: (RxSwift.Observable<Self.Element>) -> Result) -> Result
  public func drive<R1, R2>(_ with: (RxSwift.Observable<Self.Element>) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func drive<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> RxSwift.Disposable where Object : AnyObject
  public func drive(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> RxSwift.Disposable
  public func drive() -> RxSwift.Disposable
}
extension RxCocoa.SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.SignalSharingStrategy {
  public func emit<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  public func emit<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  public func emit(to relays: RxRelay.BehaviorRelay<Self.Element>...) -> RxSwift.Disposable
  public func emit(to relays: RxRelay.BehaviorRelay<Self.Element?>...) -> RxSwift.Disposable
  public func emit(to relays: RxRelay.PublishRelay<Self.Element>...) -> RxSwift.Disposable
  public func emit(to relays: RxRelay.PublishRelay<Self.Element?>...) -> RxSwift.Disposable
  public func emit(to relays: RxRelay.ReplayRelay<Self.Element>...) -> RxSwift.Disposable
  public func emit(to relays: RxRelay.ReplayRelay<Self.Element?>...) -> RxSwift.Disposable
  public func emit<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> RxSwift.Disposable where Object : AnyObject
  public func emit(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> RxSwift.Disposable
  public func emit() -> RxSwift.Disposable
}
public enum RxCocoaError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case invalidOperation(object: Any)
  case itemsNotYetBound(object: Any)
  case invalidPropertyName(object: Any, propertyName: Swift.String)
  case invalidObjectOnKeyPath(object: Any, sourceObject: Swift.AnyObject, propertyName: Swift.String)
  case errorDuringSwizzling
  case castingError(object: Any, targetType: Any.Type)
}
extension RxCocoa.RxCocoaError {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SharedSequence<SharingStrategy, Element> : RxCocoa.SharedSequenceConvertibleType, RxSwift.ObservableConvertibleType where SharingStrategy : RxCocoa.SharingStrategyProtocol {
  public func asObservable() -> RxSwift.Observable<Element>
  public func asSharedSequence() -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public func asInfallible() -> RxSwift.Infallible<Element>
}
public protocol SharingStrategyProtocol {
  static var scheduler: RxSwift.SchedulerType { get }
  static func share<Element>(_ source: RxSwift.Observable<Element>) -> RxSwift.Observable<Element>
}
public protocol SharedSequenceConvertibleType : RxSwift.ObservableConvertibleType {
  associatedtype SharingStrategy : RxCocoa.SharingStrategyProtocol
  func asSharedSequence() -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func asObservable() -> RxSwift.Observable<Self.Element>
}
extension RxCocoa.SharedSequence {
  public static func empty() -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func never() -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func just(_ element: Element) -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func deferred(_ observableFactory: @escaping () -> RxCocoa.SharedSequence<SharingStrategy, Element>) -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func of(_ elements: Element...) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension RxCocoa.SharedSequence {
  public static func from(_ array: [Element]) -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func from<Sequence>(_ sequence: Sequence) -> RxCocoa.SharedSequence<SharingStrategy, Element> where Element == Sequence.Element, Sequence : Swift.Sequence
  public static func from(optional: Element?) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension RxCocoa.SharedSequence where Element : Swift.FixedWidthInteger {
  public static func interval(_ period: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension RxCocoa.SharedSequence where Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: RxSwift.RxTimeInterval, period: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension RxCocoa.SharedSequence {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension RxSwift.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> RxSwift.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : RxCocoa.KVORepresentable
}
extension RxSwift.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial]) -> RxSwift.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : RxCocoa.KVORepresentable
}
extension CoreGraphics.CGRect : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGRect.KVOType)
}
extension CoreGraphics.CGPoint : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGPoint.KVOType)
}
extension CoreGraphics.CGSize : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGSize.KVOType)
}
extension RxSwift.ObservableType {
  public func bind<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind<Object>(with object: Object, onNext: @escaping (Object, Self.Element) -> Swift.Void) -> RxSwift.Disposable where Object : AnyObject
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> RxSwift.Disposable
}
extension RxRelay.PublishRelay {
  final public func asSignal() -> RxCocoa.Signal<Element>
}
public typealias Signal<Element> = RxCocoa.SharedSequence<RxCocoa.SignalSharingStrategy, Element>
public struct SignalSharingStrategy : RxCocoa.SharingStrategyProtocol {
  public static var scheduler: RxSwift.SchedulerType {
    get
  }
  public static func share<Element>(_ source: RxSwift.Observable<Element>) -> RxSwift.Observable<Element>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.SignalSharingStrategy {
  public func asSignal() -> RxCocoa.Signal<Self.Element>
}
extension RxSwift.ObservableConvertibleType {
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorJustReturn: Self.Element) -> RxCocoa.SharedSequence<S, Self.Element> where S : RxCocoa.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorDriveWith: RxCocoa.SharedSequence<S, Self.Element>) -> RxCocoa.SharedSequence<S, Self.Element> where S : RxCocoa.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorRecover: @escaping (_ error: Swift.Error) -> RxCocoa.SharedSequence<S, Self.Element>) -> RxCocoa.SharedSequence<S, Self.Element> where S : RxCocoa.SharingStrategyProtocol
}
public protocol ControlPropertyType : RxSwift.ObservableType, RxSwift.ObserverType {
  func asControlProperty() -> RxCocoa.ControlProperty<Self.Element>
}
public struct ControlProperty<PropertyType> : RxCocoa.ControlPropertyType {
  public typealias Element = PropertyType
  public init<Values, Sink>(values: Values, valueSink: Sink) where PropertyType == Values.Element, Values : RxSwift.ObservableType, Sink : RxSwift.ObserverType, Values.Element == Sink.Element
  public func subscribe<Observer>(_ observer: Observer) -> RxSwift.Disposable where PropertyType == Observer.Element, Observer : RxSwift.ObserverType
  public var changed: RxCocoa.ControlEvent<PropertyType> {
    get
  }
  public func asObservable() -> RxSwift.Observable<RxCocoa.ControlProperty<PropertyType>.Element>
  public func asControlProperty() -> RxCocoa.ControlProperty<RxCocoa.ControlProperty<PropertyType>.Element>
  public func on(_ event: RxSwift.Event<RxCocoa.ControlProperty<PropertyType>.Element>)
}
extension RxCocoa.ControlPropertyType where Self.Element == Swift.String? {
  public var orEmpty: RxCocoa.ControlProperty<Swift.String> {
    get
  }
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func map<Result>(_ selector: @escaping (Self.Element) -> Result) -> RxCocoa.SharedSequence<Self.SharingStrategy, Result>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func compactMap<Result>(_ selector: @escaping (Self.Element) -> Result?) -> RxCocoa.SharedSequence<Self.SharingStrategy, Result>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func filter(_ predicate: @escaping (Self.Element) -> Swift.Bool) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element : RxCocoa.SharedSequenceConvertibleType {
  public func switchLatest() -> RxCocoa.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func flatMapLatest<Sharing, Result>(_ selector: @escaping (Self.Element) -> RxCocoa.SharedSequence<Sharing, Result>) -> RxCocoa.SharedSequence<Sharing, Result> where Sharing : RxCocoa.SharingStrategyProtocol
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func flatMapFirst<Sharing, Result>(_ selector: @escaping (Self.Element) -> RxCocoa.SharedSequence<Sharing, Result>) -> RxCocoa.SharedSequence<Sharing, Result> where Sharing : RxCocoa.SharingStrategyProtocol
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func `do`(onNext: ((Self.Element) -> Swift.Void)? = nil, afterNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, afterCompleted: (() -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) -> Key) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) -> K, comparer: @escaping (K, K) -> Swift.Bool) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func flatMap<Sharing, Result>(_ selector: @escaping (Self.Element) -> RxCocoa.SharedSequence<Sharing, Result>) -> RxCocoa.SharedSequence<Sharing, Result> where Sharing : RxCocoa.SharingStrategyProtocol
}
extension RxCocoa.SharedSequenceConvertibleType {
  public static func merge<Collection>(_ sources: Collection) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: [RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>]) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>...) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.Element : RxCocoa.SharedSequenceConvertibleType {
  public func merge() -> RxCocoa.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> RxCocoa.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func throttle(_ dueTime: RxSwift.RxTimeInterval, latest: Swift.Bool = true) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public func debounce(_ dueTime: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) -> A) -> RxCocoa.SharedSequence<Self.SharingStrategy, A>
}
extension RxCocoa.SharedSequence {
  public static func concat<Sequence>(_ sequence: Sequence) -> RxCocoa.SharedSequence<SharingStrategy, Element> where Sequence : Swift.Sequence, Sequence.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func concat<Collection>(_ collection: Collection) -> RxCocoa.SharedSequence<SharingStrategy, Element> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension RxCocoa.SharedSequence {
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> RxCocoa.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func zip<Collection>(_ collection: Collection) -> RxCocoa.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension RxCocoa.SharedSequence {
  public static func combineLatest<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> RxCocoa.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func combineLatest<Collection>(_ collection: Collection) -> RxCocoa.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.SignalSharingStrategy {
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> RxCocoa.SharedSequence<Self.SharingStrategy, Out> where Object : AnyObject
  public func withUnretained<Object>(_ obj: Object) -> RxCocoa.SharedSequence<Self.SharingStrategy, (Object, Self.Element)> where Object : AnyObject
}
extension RxCocoa.SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.DriverSharingStrategy {
  @available(*, unavailable, message: "withUnretained has been deprecated for Driver. Consider using `drive(with:onNext:onCompleted:onDisposed:)`, instead")
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> RxCocoa.SharedSequence<Self.SharingStrategy, Out> where Object : AnyObject
  @available(*, unavailable, message: "withUnretained has been deprecated for Driver. Consider using `drive(with:onNext:onCompleted:onDisposed:)`, instead")
  public func withUnretained<Object>(_ obj: Object) -> RxCocoa.SharedSequence<Self.SharingStrategy, (Object, Self.Element)> where Object : AnyObject
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func withLatestFrom<SecondO, ResultType>(_ second: SecondO, resultSelector: @escaping (Self.Element, SecondO.Element) -> ResultType) -> RxCocoa.SharedSequence<Self.SharingStrategy, ResultType> where SecondO : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == SecondO.SharingStrategy
  public func withLatestFrom<SecondO>(_ second: SecondO) -> RxCocoa.SharedSequence<Self.SharingStrategy, SecondO.Element> where SecondO : RxCocoa.SharedSequenceConvertibleType
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func skip(_ count: Swift.Int) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func startWith(_ element: Self.Element) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func delay(_ dueTime: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension Swift.Int : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int.KVOType)
}
extension Swift.Int32 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int32.KVOType)
}
extension Swift.Int64 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int64.KVOType)
}
extension Swift.UInt : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt.KVOType)
}
extension Swift.UInt32 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt32.KVOType)
}
extension Swift.UInt64 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt64.KVOType)
}
extension Swift.Bool : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Bool.KVOType)
}
extension RxSwift.ObservableConvertibleType {
  public func asDriver(onErrorJustReturn: Self.Element) -> RxCocoa.Driver<Self.Element>
  public func asDriver(onErrorDriveWith: RxCocoa.Driver<Self.Element>) -> RxCocoa.Driver<Self.Element>
  public func asDriver(onErrorRecover: @escaping (_ error: Swift.Error) -> RxCocoa.Driver<Self.Element>) -> RxCocoa.Driver<Self.Element>
}
public struct KeyValueObservingOptions : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let initial: RxCocoa.KeyValueObservingOptions
  public static let new: RxCocoa.KeyValueObservingOptions
  public typealias ArrayLiteralElement = RxCocoa.KeyValueObservingOptions
  public typealias Element = RxCocoa.KeyValueObservingOptions
  public typealias RawValue = Swift.UInt
}
extension RxSwift.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> RxSwift.Observable<Element?> where Element : RxCocoa.KVORepresentable
}
extension RxSwift.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial]) -> RxSwift.Observable<Element?> where Element : RxCocoa.KVORepresentable
}
extension RxCocoa.ControlProperty {
  public func asDriver() -> RxCocoa.Driver<RxCocoa.ControlProperty<PropertyType>.Element>
}
open class DelegateProxy<P, D> : RxCocoa._RXDelegateProxy where P : AnyObject {
  public typealias ParentObject = P
  public typealias Delegate = D
  public init<Proxy>(parentObject: RxCocoa.DelegateProxy<P, D>.ParentObject, delegateProxy: Proxy.Type) where P == Proxy.ParentObject, D == Proxy.Delegate, Proxy : RxCocoa.DelegateProxy<P, D>, Proxy : RxCocoa.DelegateProxyType
  open func sentMessage(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  open func methodInvoked(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  @objc override dynamic open func _sentMessage(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  @objc override dynamic open func _methodInvoked(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  open func forwardToDelegate() -> RxCocoa.DelegateProxy<P, D>.Delegate?
  open func setForwardToDelegate(_ delegate: RxCocoa.DelegateProxy<P, D>.Delegate?, retainDelegate: Swift.Bool)
  @objc override dynamic open func responds(to aSelector: ObjectiveC.Selector!) -> Swift.Bool
  @objc deinit
}
extension RxSwift.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> RxSwift.Observable<Element?>
  public func observe<Element>(_ keyPath: Swift.KeyPath<Base, Element>, options: Foundation.NSKeyValueObservingOptions = [.new, .initial]) -> RxSwift.Observable<Element>
}
extension RxSwift.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial]) -> RxSwift.Observable<Element?>
}
extension RxSwift.Reactive where Base : AnyObject {
  public var deallocated: RxSwift.Observable<Swift.Void> {
    get
  }
  public func sentMessage(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  public func methodInvoked(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  public var deallocating: RxSwift.Observable<()> {
    get
  }
}
extension RxSwift.Reactive where Base : Foundation.NotificationCenter {
  public func notification(_ name: Foundation.Notification.Name?, object: Swift.AnyObject? = nil) -> RxSwift.Observable<Foundation.Notification>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension RxCocoa.SharedSequence {
  @_Concurrency.MainActor public var values: _Concurrency.AsyncStream<Element> {
    get
  }
}
extension RxCocoa.RxCocoaInterceptionMechanism : Swift.Equatable {}
extension RxCocoa.RxCocoaInterceptionMechanism : Swift.Hashable {}
